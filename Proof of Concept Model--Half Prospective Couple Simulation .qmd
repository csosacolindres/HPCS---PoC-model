---
title: "Proof-of-Concept Model: Half-Prospective Couple Simulation"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Half-Prospective Couple Simulation: Proof-of-Concept Model

## Background

Couple Simulation might be able to predict who people will end up with (maybe *should* end up with). However, as it stands right now, couple simulation has only been retrospective---that is, has only reconstructed relationships that already exist.

Constructing a Prospective Couple Simulation study would be challenging with less-than-it's-worth gains: You'd need to design a longitudinal study with a closed mating market; longitudinal studies have high attrition, and closed mating markets (like isolated societies, retirement homes, etc) are unrepresentative and rare. Stacking on to the logistical challenges, replication would be challenging for any other researcher attempting to replicate the findings. However, this may be an inverted U problem where the solution to "what study design is ideal given the circumstances?" lies somewhere in the middle.

A Half-Prospective Couple Simulation could serve to mitigate the challenges of a full Prospective Couple Simulation. Here we can compare alternative models (Random, GSA, RAM) to prospectively predict the *KINDS* of partners people choose. This design is cheaper, easier, and reproducible---it does not require a closed market, or dyadic data so gathering a large uncoupled population can help attrition rates.

What is a Half-Prospective Couple Simulation?

![](images/Screenshot%202023-07-18%20at%201.13.15%20PM.png)

### The Proof-of-Concept Model:

To test whether in fact a Half-Prospective Couple Simulation could be a good alternative to a full Prospective Couple Simulation, we need to construct a proof-of-concept model.

What is the Proof-of-Concept Model for the Half-Prospective Couple Simulation design?

![](images/Screenshot%202023-07-18%20at%201.22.50%20PM.png)

Here, the key questions are:

1.  Are secondary partners significantly more similar to primary partners than expected by chance?

2.  Does this not happen when choice is random with respect to preferences?

3.  Are matches significantly more similar when the secondary mate choice model matches the primary?

### Model Outline:

Sections:

1.  Create all populations

    -   Primary Population

        -   PP Male & PP Female

    -   Secondary Population

        -   SP Male & SP Female

    -   Split/Combine Populations

        -   PP Male & SP Female

        -   PP Female & SP Male

2.  Construct the Couple Simulation Algorithm

3.  Run PP through Couple Simulation

    -   Save data on

        -   Couples that form

        -   Agents' traits

4.  Run S/C populations through Couple Simulation

    -   Save data on

        -   Couples that form

        -   Agents' traits

5.  Answer Key Questions

    1.  Are secondary partners significantly more similar to primary partners than expected by chance?

        -   Compare Secondary Partners to Primary Partners
        -   What does the difference / distance mean for \^ ?
            -   permutation test

    2.  Does this not happen when choice is random with respect to preferences?

        -   Compare Couple Simulation models (Random, GSA, RAM)

            -   Random vs. GSA

            -   Random vs. RAM

    3.  Are matches significantly more similar when the secondary mate choice model matches the primary?

        -   Compare Combinations of Couple Simulation Models

            -   PP CS using Random & S/C CS using Random

            -   PP CS using Random & S/C CS using GSA

            -   PP CS using Random & S/C CS using RAM

            -   PP CS using GSA & S/C CS using Random

            -   PP CS using GSA & S/C CS using GSA

            -   PP CS using GSA & S/C CS using RAM

            -   PP CS using RAM & S/C CS using Random

            -   PP CS using RAM & S/C CS using GSA

            -   PP CS using RAM & S/C CS using RAM

## HPCS PoC model

### Library

```{r library}

library(ggplot2)
```

### Human Data

```{r humanData}
#Human Data#
#Load in the human data for parameterizing agents
hdata <- read.csv("CAREER1 PROCESSED Data 01172020 104258.csv")

#Remove unnecessary columns from the human data
hdata <- hdata[, c(1, 3:10, 235:250, 345:360)]

#Make sure there's no missing information
hdata <- hdata[complete.cases(hdata[, c(10:25, 26:41)]), ]

```

### Parameters

```{r parameters}

# Pop size 
popsize <- nrow(hdata)

# model loops
partSimLoops <- 30

```

### Functions

```{r functions}

### Agent Generation ####
agentGenerate <- function(popsize, sex, data) {
  #Generate agents with trait and preferences by resampling from the human data
  agents <- apply(data[, c(10:25, 26:41)], 2, function(x)
    sample(x, popsize, replace = T))
  
  #Standardize ratings
  agents <- t(apply(agents, 2, scale))
  
  #Create a copy of the human dataframe including just the required variables
  hdata1 <- data[, as.numeric(c(10:25, 26:41))]
  
  #Calculates the correlation matrix for traits and preferences in the real data
  hdata1cor <- cor(hdata1)
  
  #Computes the Cholesky decomposition of this matrix
  #This will impose a realistic covariance matrix on the simulated data
  hdata1chol <- t(chol(hdata1cor, pivot = T))
  
  #Multiplies the scaled agent data by the Cholesky decomposition
  #This imposes approximately the correct covariance matrix
  agents <- t(hdata1chol %*% agents)
  
  #Add the mean of each variable to the simulated data to re-center data
  agents <-
    sapply(1:ncol(agents), function(x)
      (sd(hdata1[, x]) * agents[, x]) + mean(hdata1[, x]))
  
  
  #Truncate rated variables to the true mini and max found in the human data
  agents <- sapply(1:ncol(agents), function(x)
    ifelse(agents[, x] > max(hdata1[, x]), max(hdata1[, x]), agents[, x]))
  
  agents <- sapply(1:ncol(agents), function(x)
    ifelse(agents[, x] < min(hdata1[, x]), min(hdata1[, x]), agents[, x]))
  
  #Names variables appropriately
  colnames(agents) <- colnames(hdata1)
  
  return(as.data.frame(cbind(sex, agents)))
}





### Mate Value Calculation ###
mvcalc <- function(ideal, traits) {
  #ideal is ideal preferences
  #traits is actual trait values
  
  #Calculates the Euclidean distance between the agent's preferences and each mate's traits
  #Transforms this distance such that positive values are more attractive by multiplying by -1 and
  #adding 1 plus the maximum possible Euclidean distance
  mv <- apply(traits, 1, function(x)
    10 * (-1 * (dist(rbind(
      ideal, x
    ))) + sqrt(10 ^ 2 * 16)) / sqrt(10 ^ 2 * 16))
  
  
  return(mv)
  
}



simCalc <- function(ppPartner, scPartner, pp, sc) {
  sim <- 0
  if (!(is.na(scPartner))) {
    sim <- 10 * (-1 * (dist(rbind(pp[pp$PIN == ppPartner, 18:33],
                                  sc[sc$PIN == scPartner, 18:33]))) + sqrt(10 ^ 2 * 16)) / sqrt(10 ^ 2 * 16)
    
  }
  
  return(sim)
  
}


### T1 and T2 Partner Similarity ###
partnerSimilarity <- function(pp, sc, random = F) {
  
  pp <- pp[complete.cases(pp$modelguess),]
  
  partnerSim <- rep(0, nrow(pp))
  for (p in 1:nrow(pp)) {
    if (random == F) {
      ppPartner <- pp$modelguess[p]
      
    } else {
      ppPartner <-
        pp$modelguess[sample((1:nrow(pp))[pp$sex == pp$sex[p]], 1)]
    }
    
    scPartner <- sc$modelguess[sc$PIN == pp$PIN[p]]
    
    partnerSim[p] <- simCalc(ppPartner, scPartner, pp, sc)
    
  }
  return(partnerSim)
}





### Improved Sampling ###
#A sample function that will return a single scalar if given it
resample <- function(x,...){if(length(x)==1) x else sample(x,...)} 
```

```{r coupleSimulationFunction}


#Mate Choice#
matechoice <- function(females, males, mca = "ram") {
  ######Computing Attraction######
  #mvcalc <- function(ideal, min, max, imp, rank, traits, type = "euc", power=2)
  
  # Males #
  #Calculate how attracted each male is to each female
  maleattmatrix <- t(apply(males, 1, function(q)
    mvcalc(as.numeric(q[2:17]),
           females[, c(18:33)])))
  
  colnames(maleattmatrix) <- females$PIN
  rownames(maleattmatrix) <- males$PIN
  
  
  # Females #
  #Calculate how attracted each female is to each male
  femaleattmatrix <- t(apply(females, 1, function(q)
    mvcalc(as.numeric(q[2:17]),
           males[, c(18:33)])))
  
  colnames(femaleattmatrix) <- males$PIN
  rownames(femaleattmatrix) <- females$PIN
  
  
  
  
  
  
  
  
  ###### Mate Choice ######
  if (mca == "gsa") {
    #A blank dataframe for storing the paired couples
    pairs <- matrix(, 1, (ncol(males) + ncol(females)))
    pairs <- as.data.frame(pairs)
    
    #Name the pairs dataframe for cbinding
    colnames(pairs) <- c(colnames(females), colnames(males))
    
    #A vector of male agents' partners
    mpartner <- matrix(0, nrow(males), 1)
    
    #A vector of female agents' partners
    fpartner <- matrix(0, nrow(females), 1)
    
    #A matrix of females have already rejected each male
    mrejected <- matrix(0, nrow(males), nrow(females))
    
    
    #Loops as long as some male is still unpaired
    while (sum(mpartner == 0, na.rm = T) > 0) {
      #Selects the first unpaired male
      focalmale <- which(mpartner == 0)[1]
      
      #Pulls out his attractions
      focalmaleatts <- maleattmatrix[focalmale, ]
      
      #Determines which females have already rejected him
      focalmalerejections <- mrejected[focalmale, ]
      
      #If there is still a female left who has not rejected the focal male...
      if (sum(focalmalerejections) < nrow(females)) {
        #Sets the attractiveness of each female who has rejected the focal male to 0
        focalmaleatts[focalmalerejections == 1] <- 0
        
        #Determines which of the remaining females he is most attracted to
        femalechosen <-
          which(focalmaleatts == max(focalmaleatts))[1]
        
        #If she is single...
        if (fpartner[femalechosen] == 0) {
          #She provisionally pairs with him
          fpartner[femalechosen] <- focalmale
          
          #And he provisionally pairs with her
          mpartner[focalmale] <- femalechosen
          
          #If the chosen female is not single, she compares the attractiveness of the focal male to her current partner...
        } else if (femaleattmatrix[femalechosen, focalmale] >
                   femaleattmatrix[femalechosen, fpartner[femalechosen]]) {
          #If the focal male is more attractive to the chosen female than her current partner...
          
          #The chosen female rejects her current partner
          mrejected[fpartner[femalechosen], femalechosen] <- 1
          
          #And he becomes single
          mpartner[fpartner[femalechosen]] <- 0
          
          #And the focal male and the chosen female provisionally pair
          mpartner[focalmale] <- femalechosen
          fpartner[femalechosen] <- focalmale
        } else {
          #If the focal male is not more attractive to the chosen female than her current partner, the chosen female rejects the focal male
          mrejected[focalmale, femalechosen] <- 1
        }
      } else {
        #If there is no female who has yet to reject the male, have him abandon search
        mpartner[focalmale] <- NA
      }
    }
    
    mpartner <- mpartner[is.na(mpartner) == F]
    
    #Loop through males' choices
    for (p in 1:length(mpartner)) {
      #Pair each male with his chosen female
      pairs <-
        rbind(pairs, cbind(females[mpartner[p], ], males[p, ]))
    }
    
    #Remove the row of NAs from the pairs dataframe
    pairs <- pairs[-1, ]
    
    
    #Determine the PINs of all guessed pairs
    modelrels <-
      data.frame("females" = pairs[, 34], "males" = pairs[, 68])
    
    
    #Store the mate guessed by each model for each agent for females
    females$modelguess <-
      modelrels$males[match(females$PIN, modelrels$females)]
    
    #Do the same for males
    males$modelguess <-
      modelrels$females[match(males$PIN, modelrels$males)]
    
    
    #Put the data back together
    data2 <- rbind(females, males)
    
  }
  
  
  
  
  
  
  
  
  
  if (mca == "ram") {
    #A blank dataframe for storing the paired couples
    pairs <- matrix(, 1, (ncol(males) + ncol(females)))
    pairs <- as.data.frame(pairs)
    
    #Name the pairs dataframe for cbinding
    colnames(pairs) <- c(colnames(females), colnames(males))
    
    #A matrix for storing how much investment each agent sends to each potential mate
    #Start with how attracted each agent is to each potential mate
    maleinvestprops <- maleattmatrix
    femaleinvestprops <- femaleattmatrix
    
    maleinvestprops <-
      t(apply(maleinvestprops, 1, function(x)
        x * (10 / sum(x))))
    femaleinvestprops <-
      t(apply(femaleinvestprops, 1, function(x)
        x * (10 / sum(x))))
    
    #Loop through 100 timesteps for courtship
    for (c in 1:100) {
      #How much investment each male agent received from each female agent in the previous timestep
      maleinvestpropr <- t(femaleinvestprops)
      
      #How much investment each female agent received from each male agent in the previous timestep
      femaleinvestpropr <- t(maleinvestprops)
      
      #Calculate how much investment each agent will send in this round.
      #Investment after the first round is proportional to the mutual investment in the previous round
      maleinvestprops <- maleinvestprops * maleinvestpropr
      femaleinvestprops <- femaleinvestprops * femaleinvestpropr
      
      maleinvestprops <-
        t(apply(maleinvestprops, 1, function(x)
          x * (10 / sum(x))))
      femaleinvestprops <-
        t(apply(femaleinvestprops, 1, function(x)
          x * (10 / sum(x))))
      
      #Some models can produce NaNs. This just converts these to 0
      maleinvestprops[is.nan(maleinvestprops)] <- 0
      femaleinvestprops[is.nan(femaleinvestprops)] <- 0
    }
    
    #Determine which female each male has chosen
    mchoice <- data.frame("male" = 1:nrow(males))
    mchoice$choice <-
      apply(maleinvestprops, 1, function(x)
        resample(which.max(x), 1))
    
    #Determine which male each female has chosen
    fchoice <- data.frame("female" = 1:nrow(females))
    fchoice$choice <-
      apply(femaleinvestprops, 1, function(x)
        resample(which.max(x), 1))
    
    #Loop through females' choices
    for (p in 1:nrow(fchoice)) {
      #Determine the male chosen by the current focal female
      chosenmale <- fchoice$choice[p]
      
      #Determine the female chosen by the focal female's choice
      chosenfemale <- mchoice$choice[chosenmale]
      
      #If the chosen female is the focal female...
      if (chosenfemale == p) {
        #Pair the male and female together
        pairs <-
          rbind(pairs, cbind(females[p,], males[chosenmale,]))
      }
      
      #Otherwise do nothing
      
    }
    
    #Remove the row of NAs from the pairs dataframe
    pairs <- pairs[-1,]
    
    #Determine the PINs of all guessed pairs
    modelrels <-
      data.frame("females" = pairs[, 34], "males" = pairs[, 68])
    
    
    #Store the mate guessed by each model for each agent for females
    females$modelguess <-
      modelrels$males[match(females$PIN, modelrels$females)]
    
    #Do the same for males
    males$modelguess <-
      modelrels$females[match(males$PIN, modelrels$males)]
    
    
    #Put the data back together
    data2 <- rbind(females, males)
    
  }
  
  
  
  
  
  
  
  
  ## Add random couple sim. match randomly PINs
  if (mca == "random") {
    females$modelguess <- sample(males$PIN)
    
    # I want the males model guess to be the females pin that matches females modelguess indexed in the same order as males pin.
    for (mg in 1:nrow(males)) {
      males$modelguess[mg] <-
        females$PIN[females$modelguess == males$PIN[mg]]
    }
    
    
    data2 <- rbind(females, males)
  }
  
  
  
  
  #Compile all the outputs
  output <- data2
  
  return(output)
  
}

```

### ABM Simulation

```{r simulation}

models <- apply(expand.grid(c("gsa","ram", "random"), c("Gsa", "Ram", "Random")), 1, function(x) paste(x, collapse = ""))

modelMeans <- data.frame("loop" = rep(1:partSimLoops, each = length(models)), 
                         "model" = rep(models, times = partSimLoops), 
                         "meanSim" = NA, 
                         "p" = NA)




for(ps in 1:partSimLoops){
  
  ### Generate Primary Population ###
  pMales <- agentGenerate(popsize, 1, hdata[hdata$sex == 1,])
  pFemales <- agentGenerate(popsize, 0, hdata[hdata$sex == 0,])
  
  #Give each agent a unique PIN
  pMales$PIN <- sample(1:nrow(pMales), nrow(pMales), replace = F)
  pFemales$PIN <-
    sample(nrow(pMales):(nrow(pMales) + nrow(pFemales)), nrow(pFemales), replace =
             F) + 1
  
  ### Generate Secondary Population ###
  sMales <- agentGenerate(popsize, 1, hdata[hdata$sex == 1,])
  sFemales <- agentGenerate(popsize, 0, hdata[hdata$sex == 0,])
  
  #Give each agent a unique PIN
  sMales$PIN <-
    sample(1:nrow(sMales), nrow(sMales), replace = F) + (popsize * 2) + 1
  sFemales$PIN <-
    sample(nrow(sMales):(nrow(sMales) + nrow(sFemales)), nrow(sFemales), replace =
             F) + (popsize * 2) + 2
  
  
  
  
  
  # Run couple simulation on all the different populations 
  ppGsa <- matechoice(pFemales, pMales, mca = "gsa")
  ppRam <- matechoice(pFemales, pMales, mca = "ram")
  ppRandom <- matechoice(pFemales, pMales, mca = "random")
  
  scGsa1 <- matechoice(pFemales, sMales, "gsa")
  scGsa2 <- matechoice(sFemales, pMales, "gsa")
  scGsa <- rbind(scGsa1, scGsa2)
  
  
  scRam1 <- matechoice(pFemales, sMales, "ram")
  scRam2 <- matechoice(sFemales, pMales, "ram")
  scRam <- rbind(scRam1, scRam2)
  
  
  scRandom1 <- matechoice(pFemales, sMales, "random")
  scRandom2 <- matechoice(sFemales, pMales, "random")
  scRandom <- rbind(scRandom1, scRandom2)
  

  
  
  
    # gsaGsa; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "gsaGsa"] <-
    mean(partnerSimilarity(ppGsa, scGsa), na.rm = T)
  
  # gsaGsa; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "gsaGsa"] <-
    mean(mean(partnerSimilarity(ppGsa, scGsa), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppGsa, scGsa, random = T), na.rm = T)))
  
  
  
  
    # ramGsa; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "ramGsa"] <-
    mean(partnerSimilarity(ppRam, scGsa), na.rm = T)
  
  # ramGsa; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "ramGsa"] <-
    mean(mean(partnerSimilarity(ppRam, scGsa), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppRam, scGsa, random = T), na.rm = T)))
  
  
  
   
    # randomGsa; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "randomGsa"] <-
    mean(partnerSimilarity(ppRandom, scGsa), na.rm = T)
  
  # randomGsa; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "randomGsa"] <-
    mean(mean(partnerSimilarity(ppRandom, scGsa), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppRandom, scGsa, random = T), na.rm = T)))
  
  
  
  
  # gsaRam; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "gsaRam"] <-
    mean(partnerSimilarity(ppGsa, scRam), na.rm = T)
  
  # gsaRam; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "gsaRam"] <-
    mean(mean(partnerSimilarity(ppGsa, scRam), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppGsa, scRam, random = T), na.rm = T)))
  
  
  
     # ramRam; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "ramRam"] <-
    mean(partnerSimilarity(ppRam, scRam), na.rm = T)
  
  # ramRam; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "ramRam"] <-
    mean(mean(partnerSimilarity(ppRam, scRam), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppRam, scRam, random = T), na.rm = T)))
  
  
  
  
  
      # randomRam; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "randomRam"] <-
    mean(partnerSimilarity(ppRandom, scRam), na.rm = T)
  
  # randomRam; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "randomRam"] <-
    mean(mean(partnerSimilarity(ppRandom, scRam), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppRandom, scRam, random = T), na.rm = T)))
  
  
  
  
      # gsaRandom; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "gsaRandom"] <-
    mean(partnerSimilarity(ppGsa, scRandom), na.rm = T)
  
  # gsaRandom; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "gsaRandom"] <-
    mean(mean(partnerSimilarity(ppGsa, scRandom), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppGsa, scRandom, random = T), na.rm = T)))
  
  

  
    
      # ramRandom; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "ramRandom"] <-
    mean(partnerSimilarity(ppRam, scRandom), na.rm = T)
  
  # ramRandom; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "ramRandom"] <-
    mean(mean(partnerSimilarity(ppRam, scRandom), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppRam, scRandom, random = T), na.rm = T)))
  
  
  
  
    
      # randomRandom; recording mean performance for that loop. 
  modelMeans$meanSim[modelMeans$loop == ps &
                       modelMeans$model == "randomRandom"] <-
    mean(partnerSimilarity(ppRandom, scRandom), na.rm = T)
  
  # randomRandom; recording p value for that loop. 
  modelMeans$p[modelMeans$loop == ps &
                       modelMeans$model == "randomRandom"] <-
    mean(mean(partnerSimilarity(ppRandom, scRandom), na.rm = T) <= sapply(1:1000, function(x)
    mean(partnerSimilarity(ppRandom, scRandom, random = T), na.rm = T)))
  
  
}
```

### Model Data

```{r modelData}




```

### Graphs

```{r graphs}

# statsummary 


```

### 
