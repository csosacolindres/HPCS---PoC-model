---
title: "Proof-of-Concept Model: Half-Prospective Couple Simulation"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Half-Prospective Couple Simulation: Proof-of-Concept Model

## Background

Couple Simulation might be able to predict who people will end up with (maybe *should* end up with). However, as it stands right now, couple simulation has only been retrospective---that is, has only reconstructed relationships that already exist.

Constructing a Prospective Couple Simulation study would be challenging with less-than-it's-worth gains: You'd need to design a longitudinal study with a closed mating market; longitudinal studies have high attrition, and closed mating markets (like isolated societies, retirement homes, etc) are unrepresentative and rare. Stacking on to the logistical challenges, replication would be challenging for any other researcher attempting to replicate the findings. However, this may be an inverted U problem where the solution to "what study design is ideal given the circumstances?" lies somewhere in the middle.

A Half-Prospective Couple Simulation could serve to mitigate the challenges of a full Prospective Couple Simulation. Here we can compare alternative models (Random, GSA, RAM) to prospectively predict the *KINDS* of partners people choose. This design is cheaper, easier, and reproducible---it does not require a closed market, or dyadic data so gathering a large uncoupled population can help attrition rates.

What is a Half-Prospective Couple Simulation?

![](images/Screenshot%202023-07-18%20at%201.13.15%20PM.png)

### The Proof-of-Concept Model:

To test whether in fact a Half-Prospective Couple Simulation could be a good alternative to a full Prospective Couple Simulation, we need to construct a proof-of-concept model.

What is the Proof-of-Concept Model for the Half-Prospective Couple Simulation design?

![](images/Screenshot%202023-07-18%20at%201.22.50%20PM.png)

Here, the key questions are:

1.  Are secondary partners significantly more similar to primary partners than expected by chance?

2.  Does this not happen when choice is random with respect to preferences?

3.  Are matches significantly more similar when the secondary mate choice model matches the primary?

### Model Outline:

Sections:

1.  Create all populations

    -   Primary Population

        -   PP Male & PP Female

    -   Secondary Population

        -   SP Male & SP Female

    -   Split/Combine Populations

        -   PP Male & SP Female

        -   PP Female & SP Male

2.  Construct the Couple Simulation Algorithm

3.  Run PP through Couple Simulation

    -   Save data on

        -   Couples that form

        -   Agents' traits

4.  Run S/C populations through Couple Simulation

    -   Save data on

        -   Couples that form

        -   Agents' traits

5.  Answer Key Questions

    1.  Are secondary partners significantly more similar to primary partners than expected by chance?

        -   Compare Secondary Partners to Primary Partners
        -   What does the difference / distance mean for \^ ?
            -   permutation test

    2.  Does this not happen when choice is random with respect to preferences?

        -   Compare Couple Simulation models (Random, GSA, RAM)

            -   Random vs. GSA

            -   Random vs. RAM

    3.  Are matches significantly more similar when the secondary mate choice model matches the primary?

        -   Compare Combinations of Couple Simulation Models

            -   PP CS using Random & S/C CS using Random

            -   PP CS using Random & S/C CS using GSA

            -   PP CS using Random & S/C CS using RAM

            -   PP CS using GSA & S/C CS using Random

            -   PP CS using GSA & S/C CS using GSA

            -   PP CS using GSA & S/C CS using RAM

            -   PP CS using RAM & S/C CS using Random

            -   PP CS using RAM & S/C CS using GSA

            -   PP CS using RAM & S/C CS using RAM

What is the smallest size i could do from my model that gives me sig effect.

## HPCS PoC model

### Library

```{r library}

library(ggplot2)
library(tidyr)
library(dplyr)
library(ggsignif)

```

### Human Data

```{r humanData}
#Human Data#
#Load in the human data for parameterizing agents
hdata <- read.csv("CAREER1 PROCESSED Data 01172020 104258.csv")

#Remove unnecessary columns from the human data
hdata <- hdata[, c(1, 3:10, 235:250, 345:360)]

#Make sure there's no missing information
hdata <- hdata[complete.cases(hdata[, c(10:25, 26:41)]), ]

```

### Parameters

```{r parameters}

# Pop size 
popsize <- 1000

# model loops
partSimLoops <- 10
  
```

### Functions

```{r functions}

### Agent Generation ####
agentGenerate <- function(popsize, sex, data) {
  #Generate agents with trait and preferences by resampling from the human data
  agents <- apply(data[, c(10:25, 26:41)], 2, function(x)
    sample(x, popsize, replace = T))
  
  #Standardize ratings
  agents <- t(apply(agents, 2, scale))
  
  #Create a copy of the human dataframe including just the required variables
  hdata1 <- data[, as.numeric(c(10:25, 26:41))]
  
  #Calculates the correlation matrix for traits and preferences in the real data
  hdata1cor <- cor(hdata1)
  
  #Computes the Cholesky decomposition of this matrix
  #This will impose a realistic covariance matrix on the simulated data
  hdata1chol <- t(chol(hdata1cor, pivot = T))
  
  #Multiplies the scaled agent data by the Cholesky decomposition
  #This imposes approximately the correct covariance matrix
  agents <- t(hdata1chol %*% agents)
  
  #Add the mean of each variable to the simulated data to re-center data
  agents <-
    sapply(1:ncol(agents), function(x)
      (sd(hdata1[, x]) * agents[, x]) + mean(hdata1[, x]))
  
  
  #Truncate rated variables to the true mini and max found in the human data
  agents <- sapply(1:ncol(agents), function(x)
    ifelse(agents[, x] > max(hdata1[, x]), max(hdata1[, x]), agents[, x]))
  
  agents <- sapply(1:ncol(agents), function(x)
    ifelse(agents[, x] < min(hdata1[, x]), min(hdata1[, x]), agents[, x]))
  
  #Names variables appropriately
  colnames(agents) <- colnames(hdata1)
  
  return(as.data.frame(cbind(sex, agents)))
}





### Mate Value Calculation ###
mvcalc <- function(ideal, traits) {
  #ideal is ideal preferences
  #traits is actual trait values
  
  #Calculates the Euclidean distance between the agent's preferences and each mate's traits
  #Transforms this distance such that positive values are more attractive by multiplying by -1 and
  #adding 1 plus the maximum possible Euclidean distance
  mv <- apply(traits, 1, function(x)
    10 * (-1 * (dist(rbind(
      ideal, x
    ))) + sqrt(10 ^ 2 * 16)) / sqrt(10 ^ 2 * 16))
  
  
  return(mv)
  
}



simCalc <- function(ppPartner, scPartner, pp, sc) {
  
  sim <- 0
  
  if (!is.na(ppPartner)) {
    
    sim <- (-1 * (dist(rbind(pp[pp$PIN == ppPartner, 18:33],
                             sc[sc$PIN == scPartner, 18:33]))) +
              sqrt(10 ^ 2 * 16)) / sqrt(10 ^ 2 * 16)
    
  }
  
  return(sim)
  
}



### T1 and T2 Partner Similarity ###
partnerSimilarity <- function(pp, sc, random = F) {
  
  # identify 
  scRepeat <- sc[sc$PIN %in% pp$PIN, ]

  partnerSim <- rep(0, nrow(scRepeat))
  
  for (p in 1:nrow(scRepeat)) {
    
    if (random == F) {
      scRepeatPartner <- scRepeat$modelguess[p]
      
    } else {
      scRepeatPartner <-
        scRepeat$modelguess[sample((1:nrow(scRepeat))[scRepeat$sex == scRepeat$sex[p]], 1)]
      
    }
    
    ppPartner <- pp$modelguess[pp$PIN == scRepeat$PIN[p]]
    
    partnerSim[p] <- simCalc(ppPartner, scRepeatPartner, pp, sc)
    
  }
  return(partnerSim)
}





### Improved Sampling ###
#A sample function that will return a single scalar if given it
resample <- function(x,...){if(length(x)==1) x else sample(x,...)} 
```

```{r coupleSimulationFunction}


#Mate Choice#
matechoice <- function(females, males, mca = "ram") {
  ######Computing Attraction######
  #mvcalc <- function(ideal, min, max, imp, rank, traits, type = "euc", power=2)
  
  # Males #
  #Calculate how attracted each male is to each female
  maleattmatrix <- t(apply(males, 1, function(q)
    mvcalc(as.numeric(q[2:17]),
           females[, c(18:33)])))
  
  colnames(maleattmatrix) <- females$PIN
  rownames(maleattmatrix) <- males$PIN
  
  
  # Females #
  #Calculate how attracted each female is to each male
  femaleattmatrix <- t(apply(females, 1, function(q)
    mvcalc(as.numeric(q[2:17]),
           males[, c(18:33)])))
  
  colnames(femaleattmatrix) <- males$PIN
  rownames(femaleattmatrix) <- females$PIN
  
  
  
  
  
  
  
  
  ###### Mate Choice ######
  if (mca == "gsa") {
    #A blank dataframe for storing the paired couples
    pairs <- matrix(, 1, (ncol(males) + ncol(females)))
    pairs <- as.data.frame(pairs)
    
    #Name the pairs dataframe for cbinding
    colnames(pairs) <- c(colnames(females), colnames(males))
    
    #A vector of male agents' partners
    mpartner <- matrix(0, nrow(males), 1)
    
    #A vector of female agents' partners
    fpartner <- matrix(0, nrow(females), 1)
    
    #A matrix of females have already rejected each male
    mrejected <- matrix(0, nrow(males), nrow(females))
    
    
    #Loops as long as some male is still unpaired
    while (sum(mpartner == 0, na.rm = T) > 0) {
      #Selects the first unpaired male
      focalmale <- which(mpartner == 0)[1]
      
      #Pulls out his attractions
      focalmaleatts <- maleattmatrix[focalmale, ]
      
      #Determines which females have already rejected him
      focalmalerejections <- mrejected[focalmale, ]
      
      #If there is still a female left who has not rejected the focal male...
      if (sum(focalmalerejections) < nrow(females)) {
        #Sets the attractiveness of each female who has rejected the focal male to 0
        focalmaleatts[focalmalerejections == 1] <- 0
        
        #Determines which of the remaining females he is most attracted to
        femalechosen <-
          which(focalmaleatts == max(focalmaleatts))[1]
        
        #If she is single...
        if (fpartner[femalechosen] == 0) {
          #She provisionally pairs with him
          fpartner[femalechosen] <- focalmale
          
          #And he provisionally pairs with her
          mpartner[focalmale] <- femalechosen
          
          #If the chosen female is not single, she compares the attractiveness of the focal male to her current partner...
        } else if (femaleattmatrix[femalechosen, focalmale] >
                   femaleattmatrix[femalechosen, fpartner[femalechosen]]) {
          #If the focal male is more attractive to the chosen female than her current partner...
          
          #The chosen female rejects her current partner
          mrejected[fpartner[femalechosen], femalechosen] <- 1
          
          #And he becomes single
          mpartner[fpartner[femalechosen]] <- 0
          
          #And the focal male and the chosen female provisionally pair
          mpartner[focalmale] <- femalechosen
          fpartner[femalechosen] <- focalmale
        } else {
          #If the focal male is not more attractive to the chosen female than her current partner, the chosen female rejects the focal male
          mrejected[focalmale, femalechosen] <- 1
        }
      } else {
        #If there is no female who has yet to reject the male, have him abandon search
        mpartner[focalmale] <- NA
      }
    }
    
    mpartner <- mpartner[is.na(mpartner) == F]
    
    #Loop through males' choices
    for (p in 1:length(mpartner)) {
      #Pair each male with his chosen female
      pairs <-
        rbind(pairs, cbind(females[mpartner[p], ], males[p, ]))
    }
    
    #Remove the row of NAs from the pairs dataframe
    pairs <- pairs[-1, ]
    
    
    #Determine the PINs of all guessed pairs
    modelrels <-
      data.frame("females" = pairs[, 34], "males" = pairs[, 68])
    
    
    #Store the mate guessed by each model for each agent for females
    females$modelguess <-
      modelrels$males[match(females$PIN, modelrels$females)]
    
    #Do the same for males
    males$modelguess <-
      modelrels$females[match(males$PIN, modelrels$males)]
    
    
    #Put the data back together
    data2 <- rbind(females, males)
    
  }
  
  
  
  
  
  
  
  
  
  if (mca == "ram") {
    #A blank dataframe for storing the paired couples
    pairs <- matrix(NA, 1, (ncol(males) + ncol(females)))
    pairs <- as.data.frame(pairs)
    
    #Name the pairs dataframe for cbinding
    colnames(pairs) <- c(colnames(females), colnames(males))
    
    #Remove the row of NAs from the pairs dataframe
    pairs <- pairs[-1,]
    
    
    while (nrow(pairs) < nrow(pFemales)) {
      #Identify unpaired males and feamles
      singleFemales <- females[!(females$PIN %in% pairs[, 34]), ]
      singleMales <- males[!(males$PIN %in% pairs[, 68]), ]
      
      if (nrow(singleFemales) > 1) {
        #A matrix for storing how much investment each agent sends to each potential mate
        #Start with how attracted each agent is to each potential mate
        maleinvestprops <-
          maleattmatrix[(males$PIN %in% singleMales$PIN), (females$PIN %in% singleFemales$PIN)]
        femaleinvestprops <-
          femaleattmatrix[(females$PIN %in% singleFemales$PIN), (males$PIN %in% singleMales$PIN)]
        
        maleinvestprops <-
          t(apply(maleinvestprops, 1, function(x)
            x * (10 / sum(x))))
        
        femaleinvestprops <-
          t(apply(femaleinvestprops, 1, function(x)
            x * (10 / sum(x))))
        
        #Loop through 100 timesteps for courtship
        for (c in 1:100) {
          #How much investment each male agent received from each female agent in the previous timestep
          maleinvestpropr <- t(femaleinvestprops)
          
          #How much investment each female agent received from each male agent in the previous timestep
          femaleinvestpropr <- t(maleinvestprops)
          
          #Calculate how much investment each agent will send in this round.
          #Investment after the first round is proportional to the mutual investment in the previous round
          maleinvestprops <- maleinvestprops * maleinvestpropr
          femaleinvestprops <- femaleinvestprops * femaleinvestpropr
          
          maleinvestprops <-
            t(apply(maleinvestprops, 1, function(x)
              x * (10 / sum(x))))
          femaleinvestprops <-
            t(apply(femaleinvestprops, 1, function(x)
              x * (10 / sum(x))))
          
          #Some models can produce NaNs. This just converts these to 0
          maleinvestprops[is.nan(maleinvestprops)] <- 0
          femaleinvestprops[is.nan(femaleinvestprops)] <- 0
        }
        
        #Determine which female each male has chosen
        mchoice <- data.frame("male" = 1:nrow(singleMales))
        mchoice$choice <-
          apply(maleinvestprops, 1, function(x)
            resample(which.max(x), 1))
        
        #Determine which male each female has chosen
        fchoice <- data.frame("female" = 1:nrow(singleFemales))
        fchoice$choice <-
          apply(femaleinvestprops, 1, function(x)
            resample(which.max(x), 1))
        
        #Loop through females' choices
        for (p in 1:nrow(fchoice)) {
          #Determine the male chosen by the current focal female
          chosenmale <- fchoice$choice[p]
          
          #Determine the female chosen by the focal female's choice
          chosenfemale <- mchoice$choice[chosenmale]
          
          #If the chosen female is the focal female...
          if (chosenfemale == p) {
            #Pair the male and female together
            pairs <-
              rbind(pairs, cbind(singleFemales[p, ], singleMales[chosenmale, ]))
          }
          
          #Otherwise do nothing
          
        }
      } else{
        pairs <- rbind(pairs, cbind(singleFemales, singleMales))
      }
      
    }
    
    #Determine the PINs of all guessed pairs
    modelrels <-
      data.frame("females" = pairs[, 34], "males" = pairs[, 68])
    
    
    #Store the mate guessed by each model for each agent for females
    females$modelguess <-
      modelrels$males[match(females$PIN, modelrels$females)]
    
    #Do the same for males
    males$modelguess <-
      modelrels$females[match(males$PIN, modelrels$males)]
    
    
    #Put the data back together
    data2 <- rbind(females, males)
    
  }
  
  
  
  
  
  
  ## Add random couple sim. match randomly PINs
  if (mca == "random") {
    females$modelguess <- sample(males$PIN)
    
    # I want the males model guess to be the females pin that matches females modelguess indexed in the same order as males pin.
    for (mg in 1:nrow(males)) {
      males$modelguess[mg] <-
        females$PIN[females$modelguess == males$PIN[mg]]
    }
    
    
    data2 <- rbind(females, males)
  }
  
  
  
  
  #Compile all the outputs
  output <- data2
  
  return(output)
  
}

```

### ABM Simulation

```{r simulation}
# Take out GSA to make only RAM and Random mate choice models 
models <- c("random","gsa","ram")

modelMeans <- data.frame("loop" = rep(1:partSimLoops, each = length(models)^2),
                         "primaryModel"=rep(models,times=length(models)),
                         "secondaryModel"=rep(models,each=length(models)),
                         "meanSim" = NA, 
                         "p" = NA)


for(ps in 1:partSimLoops){
  
  ### Generate Primary Population ###
  pMales <- agentGenerate(popsize/2, 1, hdata[hdata$sex == 1,])
  pFemales <- agentGenerate(popsize/2, 0, hdata[hdata$sex == 0,])
  
  #Give each agent a unique PIN
  pMales$PIN <- sample(1:nrow(pMales), nrow(pMales), replace = F)
  pFemales$PIN <-
    sample(nrow(pMales):(nrow(pMales) + nrow(pFemales)), nrow(pFemales), replace =
             F) + 1
  
  ### Generate Secondary Population ###
  sMales <- agentGenerate(popsize/2, 1, hdata[hdata$sex == 1,])
  sFemales <- agentGenerate(popsize/2, 0, hdata[hdata$sex == 0,])
  
  #Give each agent a unique PIN
  sMales$PIN <-
    sample(1:nrow(sMales), nrow(sMales), replace = F) + (popsize * 2) + 1
  sFemales$PIN <-
    sample(nrow(sMales):(nrow(sMales) + nrow(sFemales)), nrow(sFemales), replace =
             F) + (popsize * 2) + 2
  
  
  
  
  
  # Run couple simulation on all the different populations 
  ppPairs<-lapply(models,function(x)
    matechoice(pFemales,pMales,mca=x)
    )
  
  names(ppPairs)<-models
  
  scPairs<-lapply(models,function(x)
    rbind(matechoice(pFemales,sMales,x),
          matechoice(sFemales,pMales,x))
    )
  
  names(scPairs)<-models
  
  
  
  #Create a dataframe of primary and secondary model combinations
  modelCombos<-expand.grid(models,models)
  
  for(c in 1:nrow(modelCombos)){
    
    #Identify the primary and secondary models for this combination
    primary<-modelCombos[c,1]
    secondary<-modelCombos[c,2]
    
    
    modelMeans$meanSim[modelMeans$loop == ps &
                         modelMeans$primaryModel==primary &
                         modelMeans$secondaryModel==secondary]<-
      mean(partnerSimilarity(ppPairs[[primary]],
                             scPairs[[secondary]]))
    
    
    
    modelMeans$p[modelMeans$loop == ps &
                         modelMeans$primaryModel==primary &
                         modelMeans$secondaryModel==secondary]<-
      mean(
        mean(partnerSimilarity(ppPairs[[primary]],
                                  scPairs[[secondary]])) <=
             sapply(1:10, function(x) 
               mean(partnerSimilarity(ppPairs[[primary]],
                                      scPairs[[secondary]],
                                      random=T))))
    
  }

  
}
```

### Model Data

```{r modelData}

write.csv(modelMeans, file = paste0("HpcsCmclData", Sys.time(), ".csv"))

mean(modelMeans$p[modelMeans$secondaryModel=="ram" & modelMeans$primaryModel=="ram"] <.05)


```

### Graphs

```{r graphs}

# limit to only RAM and Random 
# change plot data to just include Ram and random 
# fix the range of y axis from .0 to 1 not .8
plotdata<-modelMeans[modelMeans$primaryModel=="random"|modelMeans$primaryModel=="ram",]
plotdata<-plotdata[plotdata$secondaryModel=="random"|plotdata$secondaryModel=="ram",]

modelMeansPlot <- ggplot(data = plotdata, 
                         aes(x = secondaryModel,
                             y = meanSim,
                             fill = primaryModel)) +
  stat_summary(fun = mean,
               geom = "bar",
               position = "dodge") +
  labs(title = "Proof-of-Concept Model Results", 
       x = "Mate Choice Model at Time 2", 
       y = "Partner Similarity (Time 2 - Time 1)", 
       fill = "Mate Choice\nModel at\nTime 1") +
  theme_minimal(base_size = 15) +
  scale_y_continuous(limits = c(0, 1), breaks = c(0, .2, .4, .6, .8, 1.0)) +
  scale_fill_manual(labels = c("RAM","Random"),
                    values= c("#00798c", "#edae46")) +
  geom_signif(
    annotation = "**",
    y_position = .85, xmin = .7, xmax = 1.3,
    tip_length = c(0, 0),size = 0.6,
    textsize = 7) +
  geom_signif(
    annotation = "N.S.",
    y_position = .80, xmin = 1.7, xmax = 2.3,
    tip_length = c(0, 0),size = 0.6,
    textsize = 5) +
  scale_x_discrete(labels = c("RAM", "Random"))


#save plot
ggsave("NSF GRFP POC.jpeg", plot=modelMeansPlot, width=150, height=100, units="mm", path ="/Users/is/Desktop/Proof-of-Concept-Model", scale = 1, dpi=300, limitsize=TRUE)
  
  
```
